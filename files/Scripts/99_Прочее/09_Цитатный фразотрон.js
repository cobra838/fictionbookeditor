//======================================
//             «Цитатный фразотрон»
//======================================
// v.1.0 — Создание скрипта «Статистика строк» — Александр Ка (11.02.2024)
// v.1.1  — Ряд улучшений, в основном для статистики — Александр Ка (08.06.2024)
//======================================
// v.1.2  — Александр Ка (30.07.2024)
// + Разделение на два скрипта: «Цитатный фразотрон» и «Общая статистика».
// + Изменен алгоритм поиска строк.
// + Значительно улучено отображение цитат.
// + Улучшен поиск в стихах.
// + Добавлен поиск "Родины" и "смысла жизни".

var NumerusVersion="1.2";

function Run() {

//--------------------------------------------------------------------
//--------------------------------------------------------------------
//--------------------------------------------------------------------


                 /// ОБЩИЕ ПЕРЕМЕННЫЕ


 try { var nbspChar=window.external.GetNBSP(); var nbspEntity; if (nbspChar.charCodeAt(0)==160) nbspEntity="&nbsp;"; else nbspEntity=nbspChar }
 catch(e) { var nbspChar=String.fromCharCode(160); var nbspEntity="&nbsp;" }

 var n=0;  //   Локальная переменная для небольших областей
 var k=0;  //   Локальная переменная для небольших областей

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------



                 /// ПОИСК И ПОДСЧЕТ
                 //      (регулярные выражения)


          // Разделы

// Заголовки
 var Ttl_ = false;

// Подзаголовки
 var subt_  = false;

// Автор текста
 var textAuthor_ = false;

// Стихи
 var poem_ = false;


          // Поиск истины и мудрости
//  Стартовая формула;  основная формула;  счетчик;  массив с цитатами;  рабочий массив
 var reTrueS = new RegExp("(Родин[а-я]{1,2}|[Сс]мысл[а-я]{0,2}\\\sжизни|Путин[а-я]{0,2}|путинск[а-я]{2,3}|[Рр]азум[а-я]{0,3}|[Оо]тчизн[а-я]{1,2}|[Мм]удр[а-я]{0,5}|[Ии]стин[а-я]{0,3})([…\\\.,:;\\\?!\\\)\\\]«„“»”\\\"\\\-\\\s]|"+nbspEntity+")","g");
 var reTrue = new RegExp("([…\\\.\\\?!\\\)\\\]](\\\s|"+nbspEntity+"){1,}|^)([—–\\\-](\\\s|"+nbspEntity+"){1,}){0,1}([А-ЯA-ZЁ].{0,180}([…\\\[\\\(«„“»”\\\"\\\s]|"+nbspEntity+")){0,1}(Родин[а-я]{1,2}|[Сс]мысл[а-я]{0,2}\\\sжизни|Путин[а-я]{0,2}|путинск[а-я]{2,3}|[Рр]азум[а-я]{0,3}|[Оо]тчизн[а-я]{1,2}|[Мм]удр[а-я]{0,5}|[Ии]стин[а-я]{0,3})(([…\\\.,:;\\\?!\\\)\\\]«„“»”\\\"\\\-\\\s]|"+nbspEntity+").{0,110}.{0,120}?){0,1}[…\\\.\\\?!]","g");
 var count_True = 0;
 var MTrue=[];
 var massif=[];

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------



                 /// ПОИСК И ПОДСЧЕТ  :  Параграфы <P>
                 //      (сборка функции "HandleP")


 var sct="";  // копия абзаца без тегов и кодовых записей символов (типа "&nbsp;")
 var ptrUp;  // узлы выше строки


 function HandleP(ptr) {

   sct=ptr.innerText;  //  получение текста параграфа без тегов и числовых кодов

         // поиск внешнего форматирования
   Ttl_ = (ptr.parentNode.className=="title");         //   заголовки
   subt_ = (ptr.className=="subtitle");         //   подзаголовки
   textAuthor_ = (ptr.className=="text-author")         //   автор текста
   poem_ = (ptr.parentNode.className=="stanza")         //   стихи

         //  Объединение всех строк одной строфы (в стихах)
   if (poem_) {
           sct=ptr.parentNode.innerText;
           sct=sct.replace(/[\\\r][\\\n]/g, " /&/  ");  //  Временная замена разрывов строк (так удобней).
           }

         // поиск цитат
   if (!Ttl_  &&  !subt_  &&  !textAuthor_) {                                    // Фильтр для поиска цитат
           if (count_True<=70  &&  sct.search(reTrueS)!=-1  &&  sct.search(reTrue)!=-1) {   //  Поиск цитат, и ограничитель их количества (70 шт.)
                   massif=sct.match(reTrue);                                                //  Сохранение всех фрагментов из одного абзаца
                   for (n=0;  (n < massif.length);  n++)
                           if (massif[n].length >15)                                                 //  Пропускается только фрагмент, длиной более 15 символов
                                   { MTrue[count_True]=massif[n];  count_True++ }  //  Сохранение фрагментов текста в основном массиве
                   }
           }

   }   //  конец создания функции "HandleP(ptr)"

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------



                 /// ПОИСК И ПОДСЧЕТ  :  Параграфы <P>
                 //      (применение функции "HandleP")


 var mChild = fbw_body.children;     //  Получение всех первых разделов "fbw_body"
 var mChildLength = mChild.length;  //     их количество
 var div;
 var mP;
 var mPLength;
 var ptr;
 var j;
 var jj;
 for (var j=0;  j<mChildLength;  j++) {            //  Последовательный просмотр этих разделов
         div =   mChild[j];
         //  Далее условие для выбора раздела "DIV", который бы имел class=body, но не имел бы названия "notes" или "comments"
         if (div.nodeName == "DIV"  &&  div.className == "body"  &&  div.getAttribute("fbname") != "notes"  &&  div.getAttribute("fbname") != "comments") {
                 mP = div.getElementsByTagName("P");          //  Получение всех строк в найденном разделе
                 mPLength = mP.length;
                 for (var jj=0;  jj<mPLength;  jj++) {                //  Последовательный просмотр этих строк
                         ptr = mP[jj];
                         if (ptr.parentNode.className=="stanza")            //  Если строка в стихотворной строфе,
                                 jj += ptr.parentNode.children.length - 1;        //  то другие строки этой строфы не допускаются к отправке в функцию "HandleP"
                         HandleP(ptr); }                                         //   Применение функции "HandleP"
                 }
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------



                 /// ОКНО РЕЗУЛЬТАТОВ  :  Разбивка цитат на строки


 var reTrueS_ = new RegExp("(Путин[а-я]{0,2}|путинск[а-я]{2,3})([…\\\.,:;\\\?!\\\)\\\]«„“»”\\\"\\\-\\\s]|"+nbspEntity+")","g"); //  Для определения особого раздела
 var reS50 = new RegExp("^[…\\\.\\\?!\\\)\\\]]{1,}(\\\s|"+nbspEntity+")|(\\\s|"+nbspEntity+")[…\\\.,:;\\\?!\\\(\\\)\\\[\\\]«„“»”\\\"—–\\\-]{1,}$","g");   // Удаление лишней пунктуации
 var reS50_ = "";
 var reS60 = new RegExp("(\\\s|"+nbspEntity+")","g");   // Удвоение пробелов
 var reS60_ = "  ";
//    Пояснение  "reZit":         Разбивка на строки определенной длины
// Два пробела принимаются за один символ. Исключение: "  —", такой набор символов принимается как есть - за три символа.
//  За возможный конец строки в первую очередь принимается набор "  /&/", либо два пробела, либо строка делится без учета символов
//  При удалении "  /&/", в начале следующей строки остаются четыре пробела, которые будут служить отступом "красной строки"
 var strLength = 49;   //  длина строки
 var reZit = new RegExp("^(((  (?!—)|.){0,"+strLength+"})(  /&/)|((  (?!—)|.){0,"+strLength+"})(\\\s\\\s|$)|((  (?!—)|.){0,"+strLength+"}))(.{0,})$","g");
 var reZit_1 = "$2$5$8";
 var reZit_2 = "$10";
 var MTrue2=[];   //  Массив с цитатами, разложенными на строки

 for (n=0; n<count_True; n++) {     //  Работа с отдельными цитатами
         var ind=0;
         MTrue2[n] = [];                                           //  Добавление двухмерности в массив, принимающий строки цитат
         MTrue2[n][ind] = "";  ind++;                           //  Пустая строка, между цитатами
         if (MTrue[n].search(reTrueS_)!=-1)  MTrue2[n][ind] = "                                      ◊ ◊ ◊ ◊ ◊";
             else  MTrue2[n][ind] = "                                         ◊ ◊ ◊";           //  Добавление обычного и особого заголовка
         ind++;
         var TrueZit = "";
         TrueZit="    "+MTrue[n].replace(reS50, reS50_).replace(reS60, reS60_);      //  Обработка цитат.
         while (TrueZit != 0) {
                 MTrue2[n][ind] = TrueZit.replace(reZit, reZit_1);      //  Разбивка цитат на строки  (извлечение одной строки)
//                 ind++; MTrue2[n][ind]=MTrue2[n][ind-1].match(/(  (?!—)|.)/g).length; // длина строки
                 TrueZit = TrueZit.replace(reZit, reZit_2);                      //   (сохранение остатка цитаты)
                 ind++ }
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------



                 /// ОКНО РЕЗУЛЬТАТОВ  :  Перераспределение цитат по страницам


 var mSt=[];         //   массив строк цитат для одной страницы
 var max0=37;   //  точное число строк для цитат (высота страницы)
 var page=0;   // текущий номер страницы

 mSt[page]=[];          //  Добавление двухмерности в массив

 for (n=0;  n<count_True;  n++) {
         if (mSt[page].length+MTrue2[n].length > max0) {   //  Если строки цитаты не влазят на страницу
                 for (k=mSt[page].length;  k<max0;  k++)   //  Завершение страницы пустыми строками
                         mSt[page][k] = "";
                 page++;                             //  Увеличение номера страницы
                 mSt[page]=[];        }     //  Создание новой пустой страницы
         mSt[page] = mSt[page].concat(MTrue2[n]);
         }

 for (k=mSt[page].length;  k<max0;  k++)   //  Завершение последней страницы пустыми строками
         mSt[page][k] = "";

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------



                 /// ОКНО РЕЗУЛЬТАТОВ  :  Вывод окна результатов на экран


 var Zagolovok="             .·.·.·.                 –= ◊ =–                 .·.·.·.\n"+
                                "          ·.̉·.̉·.̉   «Цитатный фразотрон» v."+NumerusVersion+"   .̉·.̉·.̉·                            \n"+
                                "              ̉   ̉   ̉                                                      ̉   ̉   ̉ ";
 var st2="";
 var dialog="";
 var otvet;


 //  Случай, когда цитат нет
 if (count_True == 0) {
         MsgBox (Zagolovok+"\n                             Цитаты не найдены\n");
         return }

 //  Случай, когда все цитаты уместились на одной странице
 if (page == 0) {
         for (k=0;  k<max0;  k++)
                 st2 += "\n"+mSt[0][k];
         MsgBox (Zagolovok+st2+"\n\n"+
                          "   ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌  стр. "+1+"  ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ \n");
         return }

//  Последний случай, когда цитаты размещены на нескольких страницах
 for (n=0;  n<=page;  n++) {        // Цикл для страниц
         st2="";                                         //  Очистка основного текстового поля страницы
         for (k=0;  k<max0;  k++)      //  Заполнение этого поля отдельными строками из цитат
                 st2 += "\n"+mSt[n][k];
         if (n != page)  dialog="                 Показать  следующую  страницу?";    //  Варианты диалоговых строк
             else  dialog="                         Это последняя страница.\n"+
                                        "                            Вернуться на первую?";
         otvet = AskYesNo (Zagolovok+st2+"\n\n"+                                       //  Диалоговое окно (полностью собранная страница с цитатами)
                       "   ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌  стр. "+(n+1)+"  ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ ‌ \n"+dialog);
         if (!otvet)  break;              //  Завершение просмотра при отказе:  кнопка "Нет"
         if (n == page)  n=-1;       //  Переход после последней страницы, на первую (в цикле добавится +1, получится — 0)
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------



}







